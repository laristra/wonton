<!--
This file is part of the Ristra wonton project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/wonton/blob/master/LICENSE
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="Doxygen 1.8.13"/>
    <!-- For Mobile Devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <!-- Font stuff -->
    <link href='//fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'/>
    <script src="//use.fontawesome.com/3dce4d8e65.js"></script>
    <!-- the default version jquery provided by doxygen is too old for bootstrap
	 but it also contains local modifications.  we have extracted those that
	 are needed so that we can use a newer jquery. -->
    <!-- <script type="text/javascript" src="//code.jquery.com/jquery-3.1.1.min.js"></script> -->
    <script
			  src="//code.jquery.com/jquery-3.3.1.min.js"
			  integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
			  crossorigin="anonymous"></script>
      <!-- <script src="//code.jquery.com/jquery-3.3.1.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script> -->
    <script type="text/javascript" src="smartmenu.js"></script>
    <title>wonton: Wonton::StateManager&lt; MeshWrapper &gt; Class Template Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
      <!-- this version is too old for bootstrap, but it includes modifications
	   from standard jquery
    <script type="text/javascript" src="jquery.js"></script>  -->
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
    <link rel="stylesheet" href="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
<script src="//stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <!-- <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css"/> -->
    <!-- <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script> -->
  </head>
  <body>
    <nav class="navbar navbar-default" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand">wonton </a>
        </div>
      </div>
    </nav>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
      <div class="content" id="content">
        <div class="container">
          <div class="row">
            <div class="col-sm-12 panel " style="padding-bottom: 15px;">
              <div style="margin-bottom: 15px;">
      		<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceWonton.html">Wonton</a></li><li class="navelem"><a class="el" href="classWonton_1_1StateManager.html">StateManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classWonton_1_1StateManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Wonton::StateManager&lt; MeshWrapper &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="state__manager_8h_source.html">state_manager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Wonton::StateManager&lt; MeshWrapper &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classWonton_1_1StateManager.png" usemap="#Wonton::StateManager_3C_20MeshWrapper_20_3E_map" alt=""/>
  <map id="Wonton::StateManager_3C_20MeshWrapper_20_3E_map" name="Wonton::StateManager_3C_20MeshWrapper_20_3E_map">
<area href="classWonton_1_1Flat__State__Wrapper.html" title="A state manager wrapper that allows redistribution of data across nodes. " alt="Wonton::Flat_State_Wrapper&lt; MeshWrapper &gt;" shape="rect" coords="0,56,292,80"/>
<area href="classWonton_1_1Simple__State__Wrapper.html" title="A thin wrapper that implements state methods for Simple_State needed by Wonton. " alt="Wonton::Simple_State_Wrapper&lt; MeshWrapper &gt;" shape="rect" coords="302,56,594,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a86ae4cf7ddf5488ad9468886e0a639cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a86ae4cf7ddf5488ad9468886e0a639cd">StateManager</a> (const MeshWrapper &amp;mesh, std::unordered_map&lt; std::string, int &gt; <a class="el" href="classWonton_1_1StateManager.html#a1d05f0d977a66d195b990977d8011657">names</a>={}, std::unordered_map&lt; int, std::vector&lt; int &gt;&gt; material_cells={})</td></tr>
<tr class="memdesc:a86ae4cf7ddf5488ad9468886e0a639cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a86ae4cf7ddf5488ad9468886e0a639cd">More...</a><br /></td></tr>
<tr class="separator:a86ae4cf7ddf5488ad9468886e0a639cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5c04dc205ca80f02fd6c78cb9a015f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a0a5c04dc205ca80f02fd6c78cb9a015f">add_material_names</a> (const std::unordered_map&lt; std::string, int &gt; &amp;<a class="el" href="classWonton_1_1StateManager.html#a1d05f0d977a66d195b990977d8011657">names</a>)</td></tr>
<tr class="memdesc:a0a5c04dc205ca80f02fd6c78cb9a015f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the names of the materials.  <a href="#a0a5c04dc205ca80f02fd6c78cb9a015f">More...</a><br /></td></tr>
<tr class="separator:a0a5c04dc205ca80f02fd6c78cb9a015f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d05f0d977a66d195b990977d8011657"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a1d05f0d977a66d195b990977d8011657">names</a> () const</td></tr>
<tr class="memdesc:a1d05f0d977a66d195b990977d8011657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the names registered by the state manager.  <a href="#a1d05f0d977a66d195b990977d8011657">More...</a><br /></td></tr>
<tr class="separator:a1d05f0d977a66d195b990977d8011657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae830a9a2c56592e4f3ab5e258990531a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#ae830a9a2c56592e4f3ab5e258990531a">material_name</a> (int m) const</td></tr>
<tr class="memdesc:ae830a9a2c56592e4f3ab5e258990531a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of a material from its material id.  <a href="#ae830a9a2c56592e4f3ab5e258990531a">More...</a><br /></td></tr>
<tr class="separator:ae830a9a2c56592e4f3ab5e258990531a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691018efb4c6a797e500eaed51f14a96"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a691018efb4c6a797e500eaed51f14a96">get_material_id</a> (std::string const &amp;name) const</td></tr>
<tr class="memdesc:a691018efb4c6a797e500eaed51f14a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the material id from its name.  <a href="#a691018efb4c6a797e500eaed51f14a96">More...</a><br /></td></tr>
<tr class="separator:a691018efb4c6a797e500eaed51f14a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ae22955e53e5ad1d50972f501b0b6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a10ae22955e53e5ad1d50972f501b0b6b">add_material_cells</a> (std::unordered_map&lt; int, std::vector&lt; int &gt;&gt; cells)</td></tr>
<tr class="memdesc:a10ae22955e53e5ad1d50972f501b0b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the material cells.  <a href="#a10ae22955e53e5ad1d50972f501b0b6b">More...</a><br /></td></tr>
<tr class="separator:a10ae22955e53e5ad1d50972f501b0b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc4cd81c580694d700c09d15ed4866"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, std::vector&lt; int &gt; &gt; const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a1abc4cd81c580694d700c09d15ed4866">get_material_cells</a> () const</td></tr>
<tr class="memdesc:a1abc4cd81c580694d700c09d15ed4866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the material cells.  <a href="#a1abc4cd81c580694d700c09d15ed4866">More...</a><br /></td></tr>
<tr class="separator:a1abc4cd81c580694d700c09d15ed4866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71dd33fc24b1559d3443f25977406a8b"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, std::unordered_set&lt; int &gt; &gt; const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a71dd33fc24b1559d3443f25977406a8b">get_cell_materials</a> () const</td></tr>
<tr class="memdesc:a71dd33fc24b1559d3443f25977406a8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cell materials.  <a href="#a71dd33fc24b1559d3443f25977406a8b">More...</a><br /></td></tr>
<tr class="separator:a71dd33fc24b1559d3443f25977406a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6915d65d57361d84e2709e2223c3b24"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, int &gt; const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#ab6915d65d57361d84e2709e2223c3b24">get_material_shape</a> () const</td></tr>
<tr class="memdesc:ab6915d65d57361d84e2709e2223c3b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of cells for each material.  <a href="#ab6915d65d57361d84e2709e2223c3b24">More...</a><br /></td></tr>
<tr class="separator:ab6915d65d57361d84e2709e2223c3b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d70efcdcf538279cbc1e2102aca050"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a42d70efcdcf538279cbc1e2102aca050">num_materials</a> () const</td></tr>
<tr class="memdesc:a42d70efcdcf538279cbc1e2102aca050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of materials in the problem.  <a href="#a42d70efcdcf538279cbc1e2102aca050">More...</a><br /></td></tr>
<tr class="separator:a42d70efcdcf538279cbc1e2102aca050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc0bbd196a442a4e154981d935327a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#afcc0bbd196a442a4e154981d935327a2">get_entity</a> (std::string const &amp;name) const</td></tr>
<tr class="memdesc:afcc0bbd196a442a4e154981d935327a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the entity kind for a state vector.  <a href="#afcc0bbd196a442a4e154981d935327a2">More...</a><br /></td></tr>
<tr class="separator:afcc0bbd196a442a4e154981d935327a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915bb106c6cc74cdaae1000880047df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceWonton.html#a3b591a47f26a76468c30daefb3871d4e">Field_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a915bb106c6cc74cdaae1000880047df8">field_type</a> (<a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a> kind, std::string const &amp;name) const</td></tr>
<tr class="memdesc:a915bb106c6cc74cdaae1000880047df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the field type of a state vector.  <a href="#a915bb106c6cc74cdaae1000880047df8">More...</a><br /></td></tr>
<tr class="separator:a915bb106c6cc74cdaae1000880047df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40906474acf4a675532e29a327b952b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a40906474acf4a675532e29a327b952b4">get_data_size</a> (<a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a> on_what, std::string const &amp;name) const</td></tr>
<tr class="memdesc:a40906474acf4a675532e29a327b952b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the data size .  <a href="#a40906474acf4a675532e29a327b952b4">More...</a><br /></td></tr>
<tr class="separator:a40906474acf4a675532e29a327b952b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442374b98c5f4c8544674475e052edee"><td class="memItemLeft" align="right" valign="top">const std::type_info &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a442374b98c5f4c8544674475e052edee">get_data_type</a> (std::string var_name)</td></tr>
<tr class="memdesc:a442374b98c5f4c8544674475e052edee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data type of the given field.  <a href="#a442374b98c5f4c8544674475e052edee">More...</a><br /></td></tr>
<tr class="separator:a442374b98c5f4c8544674475e052edee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f11825f14bece097745c33bd7f79f6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a8f11825f14bece097745c33bd7f79f6a">add</a> (std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> &gt; sv)</td></tr>
<tr class="memdesc:a8f11825f14bece097745c33bd7f79f6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> to the state manager.  <a href="#a8f11825f14bece097745c33bd7f79f6a">More...</a><br /></td></tr>
<tr class="separator:a8f11825f14bece097745c33bd7f79f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686f55a3328e720da42ad75de8155722"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a686f55a3328e720da42ad75de8155722"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a686f55a3328e720da42ad75de8155722">add</a> (std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorUni.html">StateVectorUni</a>&lt; T &gt;&gt; sv)</td></tr>
<tr class="memdesc:a686f55a3328e720da42ad75de8155722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a StateVectorUni&lt;T&gt; to the state manager.  <a href="#a686f55a3328e720da42ad75de8155722">More...</a><br /></td></tr>
<tr class="separator:a686f55a3328e720da42ad75de8155722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d53e70d493cb23a07975cbdb28ae7b6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1d53e70d493cb23a07975cbdb28ae7b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a1d53e70d493cb23a07975cbdb28ae7b6">add</a> (std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorMulti.html">StateVectorMulti</a>&lt; T &gt;&gt; sv)</td></tr>
<tr class="memdesc:a1d53e70d493cb23a07975cbdb28ae7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a StateVectorMulti&lt;T&gt; to the state manager.  <a href="#a1d53e70d493cb23a07975cbdb28ae7b6">More...</a><br /></td></tr>
<tr class="separator:a1d53e70d493cb23a07975cbdb28ae7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9d4056fea3498d3a9c82495ab7f638"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#acc9d4056fea3498d3a9c82495ab7f638">get</a> (std::string name)</td></tr>
<tr class="memdesc:acc9d4056fea3498d3a9c82495ab7f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to a <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> from the state manager.  <a href="#acc9d4056fea3498d3a9c82495ab7f638">More...</a><br /></td></tr>
<tr class="separator:acc9d4056fea3498d3a9c82495ab7f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf9b87e9e70edcd01fac32d39844147"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> const  &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a2cf9b87e9e70edcd01fac32d39844147">get</a> (std::string name) const</td></tr>
<tr class="memdesc:a2cf9b87e9e70edcd01fac32d39844147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to a const <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> from the state manager.  <a href="#a2cf9b87e9e70edcd01fac32d39844147">More...</a><br /></td></tr>
<tr class="separator:a2cf9b87e9e70edcd01fac32d39844147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b40c9658a954ebee0740bc39861cca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45b40c9658a954ebee0740bc39861cca"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a45b40c9658a954ebee0740bc39861cca">get</a> (std::string name)</td></tr>
<tr class="memdesc:a45b40c9658a954ebee0740bc39861cca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to a templated type from the state manager.  <a href="#a45b40c9658a954ebee0740bc39861cca">More...</a><br /></td></tr>
<tr class="separator:a45b40c9658a954ebee0740bc39861cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6e3297a0b331d1fe93637d7e548b41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a6e3297a0b331d1fe93637d7e548b41"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a0a6e3297a0b331d1fe93637d7e548b41">get</a> (std::string name) const</td></tr>
<tr class="memdesc:a0a6e3297a0b331d1fe93637d7e548b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a shared pointer to a templated type from the state manager.  <a href="#a0a6e3297a0b331d1fe93637d7e548b41">More...</a><br /></td></tr>
<tr class="separator:a0a6e3297a0b331d1fe93637d7e548b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28774781f8888e52f46b04ad2dc7e852"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a28774781f8888e52f46b04ad2dc7e852">num_material_cells</a> (int m) const</td></tr>
<tr class="memdesc:a28774781f8888e52f46b04ad2dc7e852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of cells for this material id.  <a href="#a28774781f8888e52f46b04ad2dc7e852">More...</a><br /></td></tr>
<tr class="separator:a28774781f8888e52f46b04ad2dc7e852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39516c230a18c292f3c28365d5ac60a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt; const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a39516c230a18c292f3c28365d5ac60a5">get_material_cells</a> (int m) const</td></tr>
<tr class="memdesc:a39516c230a18c292f3c28365d5ac60a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cell ids for this material id.  <a href="#a39516c230a18c292f3c28365d5ac60a5">More...</a><br /></td></tr>
<tr class="separator:a39516c230a18c292f3c28365d5ac60a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb49a2dc3f3f3e35203c78e54d188f35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#afb49a2dc3f3f3e35203c78e54d188f35">mat_get_cells</a> (int m, std::vector&lt; int &gt; *matcells) const</td></tr>
<tr class="memdesc:afb49a2dc3f3f3e35203c78e54d188f35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cell ids for this material id.  <a href="#afb49a2dc3f3f3e35203c78e54d188f35">More...</a><br /></td></tr>
<tr class="separator:afb49a2dc3f3f3e35203c78e54d188f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc419be70f62b85036e56e59587be334"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abc419be70f62b85036e56e59587be334"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#abc419be70f62b85036e56e59587be334">mat_get_celldata</a> (std::string const &amp;name, int m, T const **data) const</td></tr>
<tr class="memdesc:abc419be70f62b85036e56e59587be334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cell data for this material id.  <a href="#abc419be70f62b85036e56e59587be334">More...</a><br /></td></tr>
<tr class="separator:abc419be70f62b85036e56e59587be334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd84bfde525111e83c734dffc480e7dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#abd84bfde525111e83c734dffc480e7dd">cell_index_in_material</a> (int c, int m) const</td></tr>
<tr class="memdesc:abd84bfde525111e83c734dffc480e7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cell index in this material id.  <a href="#abd84bfde525111e83c734dffc480e7dd">More...</a><br /></td></tr>
<tr class="separator:abd84bfde525111e83c734dffc480e7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad089f0f80200927f3a3d3f2412a851d8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad089f0f80200927f3a3d3f2412a851d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#ad089f0f80200927f3a3d3f2412a851d8">mat_get_celldata</a> (std::string const &amp;name, int m, T **data)</td></tr>
<tr class="memdesc:ad089f0f80200927f3a3d3f2412a851d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cell data for this material id.  <a href="#ad089f0f80200927f3a3d3f2412a851d8">More...</a><br /></td></tr>
<tr class="separator:ad089f0f80200927f3a3d3f2412a851d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e5b906277e3d8cb39ba6e3c7247f40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a56e5b906277e3d8cb39ba6e3c7247f40">cell_get_num_mats</a> (int c) const</td></tr>
<tr class="memdesc:a56e5b906277e3d8cb39ba6e3c7247f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of materials in this cell.  <a href="#a56e5b906277e3d8cb39ba6e3c7247f40">More...</a><br /></td></tr>
<tr class="separator:a56e5b906277e3d8cb39ba6e3c7247f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9540346ff87f48aa69e2b7cebb75b75"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#aa9540346ff87f48aa69e2b7cebb75b75">get_cell_materials</a> (int c) const</td></tr>
<tr class="memdesc:aa9540346ff87f48aa69e2b7cebb75b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unordered set of materials in this cell.  <a href="#aa9540346ff87f48aa69e2b7cebb75b75">More...</a><br /></td></tr>
<tr class="separator:aa9540346ff87f48aa69e2b7cebb75b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4d1caac63917a4f2e9079333d61b67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a6f4d1caac63917a4f2e9079333d61b67">cell_get_mats</a> (int c, std::vector&lt; int &gt; *cellmats) const</td></tr>
<tr class="memdesc:a6f4d1caac63917a4f2e9079333d61b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the materials in this cell.  <a href="#a6f4d1caac63917a4f2e9079333d61b67">More...</a><br /></td></tr>
<tr class="separator:a6f4d1caac63917a4f2e9079333d61b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5639be9c63f8d055954ba1ee0b009a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e5639be9c63f8d055954ba1ee0b009a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a6e5639be9c63f8d055954ba1ee0b009a">mesh_get_data</a> (<a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a> on_what, std::string const &amp;name, T const **data) const</td></tr>
<tr class="memdesc:a6e5639be9c63f8d055954ba1ee0b009a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the const cell data for this material id.  <a href="#a6e5639be9c63f8d055954ba1ee0b009a">More...</a><br /></td></tr>
<tr class="separator:a6e5639be9c63f8d055954ba1ee0b009a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a8dc4cb6aba6de899323f0cc9df6be"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a22a8dc4cb6aba6de899323f0cc9df6be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a22a8dc4cb6aba6de899323f0cc9df6be">mesh_get_data</a> (<a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a> on_what, std::string const &amp;name, T **data)</td></tr>
<tr class="memdesc:a22a8dc4cb6aba6de899323f0cc9df6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cell data for this material id.  <a href="#a22a8dc4cb6aba6de899323f0cc9df6be">More...</a><br /></td></tr>
<tr class="separator:a22a8dc4cb6aba6de899323f0cc9df6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaed84be2a10120aa533f0bde1104c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a5aaed84be2a10120aa533f0bde1104c0">mat_add_cells</a> (int m, std::vector&lt; int &gt; const &amp;newcells)</td></tr>
<tr class="memdesc:a5aaed84be2a10120aa533f0bde1104c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add cells for a new material to the material cells.  <a href="#a5aaed84be2a10120aa533f0bde1104c0">More...</a><br /></td></tr>
<tr class="separator:a5aaed84be2a10120aa533f0bde1104c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77260ef725f1fbc69e0de507450d346"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa77260ef725f1fbc69e0de507450d346"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#aa77260ef725f1fbc69e0de507450d346">mat_add_celldata</a> (std::string const &amp;name, int m, T const *values)</td></tr>
<tr class="memdesc:aa77260ef725f1fbc69e0de507450d346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add cell data for a new material in a state vector to the state manager.  <a href="#aa77260ef725f1fbc69e0de507450d346">More...</a><br /></td></tr>
<tr class="separator:aa77260ef725f1fbc69e0de507450d346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0726f61f36054cb3b0c23b0e82da72a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a0726f61f36054cb3b0c23b0e82da72a8">add_material</a> (std::string const &amp;matname, std::vector&lt; int &gt; const &amp;matcells)</td></tr>
<tr class="memdesc:a0726f61f36054cb3b0c23b0e82da72a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add cell data for a new material in a state vector to the state manager.  <a href="#a0726f61f36054cb3b0c23b0e82da72a8">More...</a><br /></td></tr>
<tr class="separator:a0726f61f36054cb3b0c23b0e82da72a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c73853580628e7d295fca610249fde"><td class="memTemplParams" colspan="2">template&lt;class T  = double&gt; </td></tr>
<tr class="memitem:aa8c73853580628e7d295fca610249fde"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#aa8c73853580628e7d295fca610249fde">shape_is_good</a> (const std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorMulti.html">StateVectorMulti</a>&lt; T &gt;&gt; sv)</td></tr>
<tr class="memdesc:aa8c73853580628e7d295fca610249fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that a StateVectorMulti&lt;T&gt; has a shape consistent with the state manager.  <a href="#aa8c73853580628e7d295fca610249fde">More...</a><br /></td></tr>
<tr class="separator:aa8c73853580628e7d295fca610249fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d1807b9d9c4c09505ce78ffa965926"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#ac5d1807b9d9c4c09505ce78ffa965926">clear_material_cells</a> ()</td></tr>
<tr class="memdesc:ac5d1807b9d9c4c09505ce78ffa965926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear material cells and the inverse map of cell materials.  <a href="#ac5d1807b9d9c4c09505ce78ffa965926">More...</a><br /></td></tr>
<tr class="separator:ac5d1807b9d9c4c09505ce78ffa965926"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a44b13a28658c43bdcd47f6cbaa9674b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a44b13a28658c43bdcd47f6cbaa9674b0">clear</a> ()</td></tr>
<tr class="separator:a44b13a28658c43bdcd47f6cbaa9674b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad1cd2f0c5a632e75522dc2caa9a28056"><td class="memItemLeft" align="right" valign="top">const MeshWrapper &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#ad1cd2f0c5a632e75522dc2caa9a28056">mesh_</a></td></tr>
<tr class="separator:ad1cd2f0c5a632e75522dc2caa9a28056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13597c52d1d15051bae2eb1d58462c70"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a13597c52d1d15051bae2eb1d58462c70">state_vectors_</a></td></tr>
<tr class="separator:a13597c52d1d15051bae2eb1d58462c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4361b1bbeeb16282b62be7d5d9f6e737"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a4361b1bbeeb16282b62be7d5d9f6e737">material_ids_</a></td></tr>
<tr class="separator:a4361b1bbeeb16282b62be7d5d9f6e737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadffac7495d7c57b17a484c7351e8bd8"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#aadffac7495d7c57b17a484c7351e8bd8">material_names_</a></td></tr>
<tr class="separator:aadffac7495d7c57b17a484c7351e8bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57ef014096668d102a3a7dd726e51ec"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#af57ef014096668d102a3a7dd726e51ec">material_cells_</a></td></tr>
<tr class="separator:af57ef014096668d102a3a7dd726e51ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e835fd58969215de41ddce4271722f6"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, std::unordered_map&lt; int, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#a9e835fd58969215de41ddce4271722f6">cell_index_in_mat_</a></td></tr>
<tr class="separator:a9e835fd58969215de41ddce4271722f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade16c4870bda0b3fe9becf46b4861acd"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, std::unordered_set&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classWonton_1_1StateManager.html#ade16c4870bda0b3fe9becf46b4861acd">cell_materials_</a></td></tr>
<tr class="separator:ade16c4870bda0b3fe9becf46b4861acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a86ae4cf7ddf5488ad9468886e0a639cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ae4cf7ddf5488ad9468886e0a639cd">&#9670;&nbsp;</a></span>StateManager()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::<a class="el" href="classWonton_1_1StateManager.html">StateManager</a> </td>
          <td>(</td>
          <td class="paramtype">const MeshWrapper &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; std::string, int &gt;&#160;</td>
          <td class="paramname"><em>names</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; int, std::vector&lt; int &gt;&gt;&#160;</td>
          <td class="paramname"><em>material_cells</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>mesh wrapper </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>map from material names to material id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">material_cells</td><td>map from material id to vector of cells</td></tr>
  </table>
  </dd>
</dl>
<p>Constructor that takes the meshwrapper for the underlying mesh and two optional map arguments: the map from material name to id, and the map from material id to the cells containing that material </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8f11825f14bece097745c33bd7f79f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f11825f14bece097745c33bd7f79f6a">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::add </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> &gt;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> to the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>shared pointer to <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a></td></tr>
  </table>
  </dd>
</dl>
<p>Add a shared pointer to a state vector to the state manager. This specialization works directly with a <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> </p>

</div>
</div>
<a id="a686f55a3328e720da42ad75de8155722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686f55a3328e720da42ad75de8155722">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::add </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorUni.html">StateVectorUni</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a StateVectorUni&lt;T&gt; to the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>shared pointer to StateVectorUni&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<p>Adds a shared pointer to a single material state vector to the state manager. This specialization works with a single material <a class="el" href="classWonton_1_1StateVectorUni.html">StateVectorUni</a> templated on type T. The code does some error checking, in particular making sure the the length of the data is the same as the number of mesh entities in the underlying mesh. </p>

</div>
</div>
<a id="a1d53e70d493cb23a07975cbdb28ae7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d53e70d493cb23a07975cbdb28ae7b6">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::add </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorMulti.html">StateVectorMulti</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a StateVectorMulti&lt;T&gt; to the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>shared pointer to StateVectorMulti&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<p>Adds a shared pointer to a multi material state vector to the state manager. This specialization works with a multi material <a class="el" href="classWonton_1_1StateVectorMulti.html">StateVectorMulti</a> templated on type T. The code does some error checking, in particular making sure the the shape of the data is the same as the shape of the material cells. </p>

</div>
</div>
<a id="a0726f61f36054cb3b0c23b0e82da72a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0726f61f36054cb3b0c23b0e82da72a8">&#9670;&nbsp;</a></span>add_material()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::add_material </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>matname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>matcells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add cell data for a new material in a state vector to the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matname</td><td>name of the material </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matcells</td><td>vector of material cells</td></tr>
  </table>
  </dd>
</dl>
<p>NOT IMPLEMENTED AT PRESENT: Starting from scratch, add the material and cell id's I think this is problematic in a distributed sense, and I don't hit it in simple_mash app, so for now don't do anything the problem is that if a rank creates it's own material id, then those could conflict with other ranks. I believe the main caller should have a registry of all materials in the problem. It should not be up to a single node to create a name&lt;-&gt;matid association. </p>

</div>
</div>
<a id="a10ae22955e53e5ad1d50972f501b0b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ae22955e53e5ad1d50972f501b0b6b">&#9670;&nbsp;</a></span>add_material_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::add_material_cells </td>
          <td>(</td>
          <td class="paramtype">std::unordered_map&lt; int, std::vector&lt; int &gt;&gt;&#160;</td>
          <td class="paramname"><em>cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the material cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cells</td><td>map from material id to vector of cell ids</td></tr>
  </table>
  </dd>
</dl>
<p>Add the material cells. The argument is a map from material id to a vector of cells for that material. </p>

</div>
</div>
<a id="a0a5c04dc205ca80f02fd6c78cb9a015f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5c04dc205ca80f02fd6c78cb9a015f">&#9670;&nbsp;</a></span>add_material_names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::add_material_names </td>
          <td>(</td>
          <td class="paramtype">const std::unordered_map&lt; std::string, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the names of the materials. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">names</td><td>map from material names to material id</td></tr>
  </table>
  </dd>
</dl>
<p>Add the names of the materials. The map from material name to id. </p>

</div>
</div>
<a id="a6f4d1caac63917a4f2e9079333d61b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4d1caac63917a4f2e9079333d61b67">&#9670;&nbsp;</a></span>cell_get_mats()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::cell_get_mats </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>cellmats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the materials in this cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>cell id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cellmats</td><td>pointer to vector of materials in this cell</td></tr>
  </table>
  </dd>
</dl>
<p>Return the unordered set of materials in this cell. While cell id's need to be kept in order within a material, the reverse is not true. Reflecting the use of an unordered set for the underlying data structure, the order of the materials is not guaranteed. NOTE: I don't believe this will handle the case of mixed mesh and multi- mat fields in the same problem. But for now, I just need to get past this. In interpolation the mesh fields are proxied by cell_get_num_mats = 0, but in the mixed case there may be mats, but still be a mesh field. Also anything that calls this should only do so if there are in fact materials which is not the case in intersect_r3d where it is always called if tangram is defined. </p>

</div>
</div>
<a id="a56e5b906277e3d8cb39ba6e3c7247f40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e5b906277e3d8cb39ba6e3c7247f40">&#9670;&nbsp;</a></span>cell_get_num_mats()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::cell_get_num_mats </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of materials in this cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>cell id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of material in this cell</dd></dl>
<p>Return the number of materials in this cell. NOTE: I don't believe this will handle the case of mixed mesh and multi- mat fields in the same problem. But for now, I just need to get past this. In interpolation the mesh fields are proxied by cell_get_num_mats = 0, but in the mixed case there may be mats, but still be a mesh field. </p>

</div>
</div>
<a id="abd84bfde525111e83c734dffc480e7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd84bfde525111e83c734dffc480e7dd">&#9670;&nbsp;</a></span>cell_index_in_material()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::cell_index_in_material </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cell index in this material id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>cell id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of cell in material</dd></dl>
<p>Return the index (location) of this cell within the list of cells for this material.</p>
<p>Get the cell index in material since this uses material dominant structures, I wish the signature was int cell_index_in_material(int m, int c) </p>

</div>
</div>
<a id="a44b13a28658c43bdcd47f6cbaa9674b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b13a28658c43bdcd47f6cbaa9674b0">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5d1807b9d9c4c09505ce78ffa965926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d1807b9d9c4c09505ce78ffa965926">&#9670;&nbsp;</a></span>clear_material_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::clear_material_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear material cells and the inverse map of cell materials. </p>

</div>
</div>
<a id="a915bb106c6cc74cdaae1000880047df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915bb106c6cc74cdaae1000880047df8">&#9670;&nbsp;</a></span>field_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceWonton.html#a3b591a47f26a76468c30daefb3871d4e">Field_type</a> <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::field_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the field type of a state vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td><a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396" title="The type of mesh entity. ">Wonton::Entity_kind</a> of the state vector (not needed) but required by the signature of mmdrive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>string of the material name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>field type (UNIMATERIAL, MULTIMATERIAL) of the state vector</dd></dl>
<p>Return the field type of a state value. The kind is not required as the names are unique. The original intent was that there could be e.g. a pressure defined on the cells and nodes but with the same same name "pressure". We moved past this, so if the name is unique, the kind is not required. the arguments are entity kind and the name of the state vector, and the return type is the field type. </p>

</div>
</div>
<a id="acc9d4056fea3498d3a9c82495ab7f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9d4056fea3498d3a9c82495ab7f638">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a>&gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a shared pointer to a <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> from the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the registered state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a></dd></dl>
<p>Gets a shared pointer to a <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> from the state manager. The pointer is to the base class and can be dynamically pointer cast to any type. The name is checked with the state manager. If the name is not found, a nullptr is returned so validity can be checked with a nullptr test. </p>

</div>
</div>
<a id="a2cf9b87e9e70edcd01fac32d39844147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf9b87e9e70edcd01fac32d39844147">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> const&gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a shared pointer to a const <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> from the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the registered state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a></dd></dl>
<p>Gets a shared pointer to a <a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a> from the state manager. The pointer is to the base class and can be dynamically pointer cast to any type. The name is checked with the state manager. If the name is not found, a nullptr is returned so validity can be checked with a nullptr test. </p>

</div>
</div>
<a id="a45b40c9658a954ebee0740bc39861cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b40c9658a954ebee0740bc39861cca">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a shared pointer to a templated type from the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the registered state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>shared pointer to a type T</dd></dl>
<p>Gets a shared pointer to a type T from the state manager. The pointer will be dynamically cast to type T. If the name is not found, a nullptr is returned so validity can be checked with a nullptr test. T is the complete type, which is likely itself templated, e.g. T = StateVectorMulti&lt;double&gt;. With this signature we only need one specialization and it is used for accessing both single material and multi material state vectors. </p>

</div>
</div>
<a id="a0a6e3297a0b331d1fe93637d7e548b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6e3297a0b331d1fe93637d7e548b41">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a shared pointer to a templated type from the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name of the registered state vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const shared pointer to a type T</dd></dl>
<p>Gets a shared pointer to a type T from the state manager. The pointer will be dynamically cast to type T. If the name is not found, a nullptr is returned so validity can be checked with a nullptr test. T is the complete type, which is likely itself templated, e.g. T = StateVectorMulti&lt;double&gt;. With this signature we only need one specialization and it is used for accessing both single material and multi material state vectors. This is a const version of the function, that is used for read only data. </p>

</div>
</div>
<a id="a71dd33fc24b1559d3443f25977406a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71dd33fc24b1559d3443f25977406a8b">&#9670;&nbsp;</a></span>get_cell_materials() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;int, std::unordered_set&lt;int&gt; &gt; const&amp; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get_cell_materials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cell materials. </p>
<dl class="section return"><dt>Returns</dt><dd>map from cell id to set of material ids</dd></dl>
<p>Return the cell materials. The return value is a map from cell id to a set of material ids. </p>

</div>
</div>
<a id="aa9540346ff87f48aa69e2b7cebb75b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9540346ff87f48aa69e2b7cebb75b75">&#9670;&nbsp;</a></span>get_cell_materials() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;int&gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get_cell_materials </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the unordered set of materials in this cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>cell id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unordered set of material ids in this cell</dd></dl>
<p>Return the unordered set of materials in this cell. While cell id's need to be kept in order within a material, the reverse is not true. The order of materials in a cell is arbitrary, so use a data structure that reflects this. Using a set makes comparing, interecting, adding etc. easy. </p>

</div>
</div>
<a id="a40906474acf4a675532e29a327b952b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40906474acf4a675532e29a327b952b4">&#9670;&nbsp;</a></span>get_data_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get_data_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a>&#160;</td>
          <td class="paramname"><em>on_what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the data size . </p>

</div>
</div>
<a id="a442374b98c5f4c8544674475e052edee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442374b98c5f4c8544674475e052edee">&#9670;&nbsp;</a></span>get_data_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::type_info&amp; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get_data_type </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>var_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the data type of the given field. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">var_name</td><td>The string name of the data field </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the type_info struct for the field's data type </dd></dl>

</div>
</div>
<a id="afcc0bbd196a442a4e154981d935327a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc0bbd196a442a4e154981d935327a2">&#9670;&nbsp;</a></span>get_entity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a> <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get_entity </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the entity kind for a state vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>string of the material name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>entity kind (CELL, NODE) of the state vector</dd></dl>
<p>Return the entity kind for a state vector. The input parameter is the name of the state vector, and the return type is a <a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396" title="The type of mesh entity. ">Wonton::Entity_kind</a> </p>

</div>
</div>
<a id="a1abc4cd81c580694d700c09d15ed4866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abc4cd81c580694d700c09d15ed4866">&#9670;&nbsp;</a></span>get_material_cells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;int, std::vector&lt;int&gt; &gt; const&amp; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get_material_cells </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the material cells. </p>
<dl class="section return"><dt>Returns</dt><dd>map from material id to vector of cell ids</dd></dl>
<p>Return the material cells. The return value is a map from material id to a vector of cells for that material. </p>

</div>
</div>
<a id="a39516c230a18c292f3c28365d5ac60a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39516c230a18c292f3c28365d5ac60a5">&#9670;&nbsp;</a></span>get_material_cells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; const&amp; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get_material_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cell ids for this material id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of cell indices containing this material</dd></dl>
<p>Return a read only reference to the cell ids for this material id. If no materials have been defined, return a reference to an empty vector. </p>

</div>
</div>
<a id="a691018efb4c6a797e500eaed51f14a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691018efb4c6a797e500eaed51f14a96">&#9670;&nbsp;</a></span>get_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get_material_id </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the material id from its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>material name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>material id</dd></dl>
<p>Return the material id from its name. </p>

</div>
</div>
<a id="ab6915d65d57361d84e2709e2223c3b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6915d65d57361d84e2709e2223c3b24">&#9670;&nbsp;</a></span>get_material_shape()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;int, int&gt; const <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::get_material_shape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of cells for each material. </p>
<dl class="section return"><dt>Returns</dt><dd>map from material id to the number of cells with this material</dd></dl>
<p>Return the number of cells for each material. The return value is a map from material id to the integer number of cells. </p>

</div>
</div>
<a id="aa77260ef725f1fbc69e0de507450d346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77260ef725f1fbc69e0de507450d346">&#9670;&nbsp;</a></span>mat_add_celldata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::mat_add_celldata </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add cell data for a new material in a state vector to the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name registered with the state manager </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>vector of data for this material</td></tr>
  </table>
  </dd>
</dl>
<p>Add cell data for a new material in a state vector to the state manager. This function takes three arguments, the name of the state vector, the material id and the data itself. The function then copies the data into the state vector. Add is a bit of a misnomer. At the moment, this sets or replaces. No merge is done. </p>

</div>
</div>
<a id="a5aaed84be2a10120aa533f0bde1104c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aaed84be2a10120aa533f0bde1104c0">&#9670;&nbsp;</a></span>mat_add_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::mat_add_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; const &amp;&#160;</td>
          <td class="paramname"><em>newcells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add cells for a new material to the material cells. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newcells</td><td>vector of cell ids containing this material</td></tr>
  </table>
  </dd>
</dl>
<p>Add cells for a new material to the material cells. This function takes two arguments, the material id and the cells containing it. The function then set the cells for this material. Add is a bit of a misnomer. At the moment, this sets or replaces. No merge is done. </p>

</div>
</div>
<a id="abc419be70f62b85036e56e59587be334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc419be70f62b85036e56e59587be334">&#9670;&nbsp;</a></span>mat_get_celldata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::mat_get_celldata </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cell data for this material id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name registered with the state manager </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>a read only pointer to the cell vector data</td></tr>
  </table>
  </dd>
</dl>
<p>Return the cell data for this material id. This is the in-place version of the function. The data is returned in a location pointed to by the user argument data. This is read-only version of the function. The vector data cannot be modified. </p>

</div>
</div>
<a id="ad089f0f80200927f3a3d3f2412a851d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad089f0f80200927f3a3d3f2412a851d8">&#9670;&nbsp;</a></span>mat_get_celldata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::mat_get_celldata </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cell data for this material id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name registered with the state manager </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>a read only pointer to the cell vector data</td></tr>
  </table>
  </dd>
</dl>
<p>Return the cell data for this material id. This is the in-place version of the function. The data is returned in a location pointed to by the user argument data. This is the non-const version of the function. The data is both writable and allocated if it doesn't exist.</p>
<p>Discussion points: This function has a side effect. When this function is called, the resulting pointer needs to point to memory that is already allocated of sufficient size. It cannot be a nullptr. At some point in the code we need to do the allocation. In our case this is an std::vector.resize call. This memory management could be done in add_material like Jali does. The downside is that this buries the allocation into a "hidden" location. I (DWS) would personally like to see add_material go away. It is responsible for creating a uid for the material in a distributed environment which is problematic and this memory management which is also problematic. The memory management is hidden here just the same, and my preferred solution is to make the allocate/resize explicit. We should add an allocate api that is called explicitly in mmdriver. That way we know exactly what we are doing when and where. It adds a step, but hopefully that will remove the segfault that developers such as myself got because we didn't know when and where to allocate the target state vectors. </p>

</div>
</div>
<a id="afb49a2dc3f3f3e35203c78e54d188f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb49a2dc3f3f3e35203c78e54d188f35">&#9670;&nbsp;</a></span>mat_get_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::mat_get_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>matcells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cell ids for this material id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">matcells</td><td>vector of cell indices containing this material</td></tr>
  </table>
  </dd>
</dl>
<p>Return the cell ids for this material id. This is the in-place version of the function. The cells are returned in a function argument rather than a function return. </p>

</div>
</div>
<a id="ae830a9a2c56592e4f3ab5e258990531a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae830a9a2c56592e4f3ab5e258990531a">&#9670;&nbsp;</a></span>material_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::material_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the name of a material from its material id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of the material name</dd></dl>
<p>Return the name of a material from its material id. </p>

</div>
</div>
<a id="a6e5639be9c63f8d055954ba1ee0b009a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e5639be9c63f8d055954ba1ee0b009a">&#9670;&nbsp;</a></span>mesh_get_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::mesh_get_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a>&#160;</td>
          <td class="paramname"><em>on_what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the const cell data for this material id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">on_what</td><td><a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396" title="The type of mesh entity. ">Wonton::Entity_kind</a> of data (unused, but required by the API) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name registered with the state manager </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>a read only pointer to the cell vector data</td></tr>
  </table>
  </dd>
</dl>
<p>Return the uni material data for this state vector. This is the in-place version of the function. The data is returned in a location pointed to by the user argument data. This is read-only version of the function. The vector data cannot be modified. </p>

</div>
</div>
<a id="a22a8dc4cb6aba6de899323f0cc9df6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a8dc4cb6aba6de899323f0cc9df6be">&#9670;&nbsp;</a></span>mesh_get_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::mesh_get_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396">Entity_kind</a>&#160;</td>
          <td class="paramname"><em>on_what</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the cell data for this material id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">on_what</td><td><a class="el" href="namespaceWonton.html#ac53f3e6fa9764c905a442e31623f5396" title="The type of mesh entity. ">Wonton::Entity_kind</a> of data (unused, but required by the API) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>name registered with the state manager </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>a pointer to the cell vector data</td></tr>
  </table>
  </dd>
</dl>
<p>Return the uni material data for this state vector. This is the in-place version of the function. The data is returned in a location pointed to by the user argument data. This is the mutable form of the function. The data may be modified by the caller. </p>

</div>
</div>
<a id="a1d05f0d977a66d195b990977d8011657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d05f0d977a66d195b990977d8011657">&#9670;&nbsp;</a></span>names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; const <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the names registered by the state manager. </p>
<dl class="section return"><dt>Returns</dt><dd>vector of strings of state names, e.g. "pressure","temp", etc</dd></dl>
<p>Return the names registered by the state manager. </p>

</div>
</div>
<a id="a28774781f8888e52f46b04ad2dc7e852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28774781f8888e52f46b04ad2dc7e852">&#9670;&nbsp;</a></span>num_material_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::num_material_cells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of cells for this material id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>material id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of cells containing this material</dd></dl>
<p>Return the number of cells for this material id. </p>

</div>
</div>
<a id="a42d70efcdcf538279cbc1e2102aca050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d70efcdcf538279cbc1e2102aca050">&#9670;&nbsp;</a></span>num_materials()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::num_materials </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of materials in the problem. </p>
<dl class="section return"><dt>Returns</dt><dd>the integer number of materials</dd></dl>
<p>Return the number of materials in the problem. Uses material_names to ensure that the materials that are expected to be, but haven't been populated with cells yet are accounted for. </p>

</div>
</div>
<a id="aa8c73853580628e7d295fca610249fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c73853580628e7d295fca610249fde">&#9670;&nbsp;</a></span>shape_is_good()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<div class="memtemplate">
template&lt;class T  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::shape_is_good </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classWonton_1_1StateVectorMulti.html">StateVectorMulti</a>&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that a StateVectorMulti&lt;T&gt; has a shape consistent with the state manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sv</td><td>shared pointer to StateVectorMulti&lt;T&gt;</td></tr>
  </table>
  </dd>
</dl>
<p>Check that a StateVectorMulti&lt;T&gt; has a shape consistent with the state manager. Both the number of materials and number of cells per material must match in order to pass the test. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9e835fd58969215de41ddce4271722f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e835fd58969215de41ddce4271722f6">&#9670;&nbsp;</a></span>cell_index_in_mat_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;int, std::unordered_map&lt;int,int&gt; &gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::cell_index_in_mat_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade16c4870bda0b3fe9becf46b4861acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade16c4870bda0b3fe9becf46b4861acd">&#9670;&nbsp;</a></span>cell_materials_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;int, std::unordered_set&lt;int&gt; &gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::cell_materials_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af57ef014096668d102a3a7dd726e51ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57ef014096668d102a3a7dd726e51ec">&#9670;&nbsp;</a></span>material_cells_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;int, std::vector&lt;int&gt; &gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::material_cells_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4361b1bbeeb16282b62be7d5d9f6e737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4361b1bbeeb16282b62be7d5d9f6e737">&#9670;&nbsp;</a></span>material_ids_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, int&gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::material_ids_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aadffac7495d7c57b17a484c7351e8bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadffac7495d7c57b17a484c7351e8bd8">&#9670;&nbsp;</a></span>material_names_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;int, std::string&gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::material_names_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1cd2f0c5a632e75522dc2caa9a28056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cd2f0c5a632e75522dc2caa9a28056">&#9670;&nbsp;</a></span>mesh_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MeshWrapper&amp; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::mesh_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13597c52d1d15051bae2eb1d58462c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13597c52d1d15051bae2eb1d58462c70">&#9670;&nbsp;</a></span>state_vectors_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MeshWrapper &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, std::shared_ptr&lt;<a class="el" href="classWonton_1_1StateVectorBase.html">StateVectorBase</a>&gt; &gt; <a class="el" href="classWonton_1_1StateManager.html">Wonton::StateManager</a>&lt; MeshWrapper &gt;::state_vectors_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/wonton/wonton/wonton/state/<a class="el" href="state__manager_8h_source.html">state_manager.h</a></li>
</ul>
</div><!-- contents -->
<!--
This file is part of the Ristra wonton project.
Please see the license file at the root of this repository, or at:
    https://github.com/laristra/wonton/blob/master/LICENSE
-->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<!--<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address> -->
<footer id="footer" class="footer">
  <div class="container">
    <div class="row test-muted">
      <div class="footer-row col-md-6">Copyright &copy; 2019
	<a href="http://lanl.gov"> Triad National Security, LLC</a>
	All Rights Reserved.
      </div>
      <div class="footer-row col-md-2">
	<a href="https://github.com/laristra/wonton/blob/master/LICENSE">
	  BSD LICENSE
	</a>
      </div>
      <div class="footer-row col-md-2">
	LA-CC-18-019
      </div>
      <div class="footer-row col-md-1">
	<a href="mailto:wonton@lanl.gov">
	  <i class="fa fa-envelope-o fa-2x"></i>
	</a>
      </div>
      <div class="footer-row col-md-1">
	<a href="https://github.com/laristra/wonton">
	  <i class="fa fa-github fa-2x"></i>
	</a>
      </div>
    </div>
  </div>
</footer>
<script type="text/javascript" src="doxy-boot.js"></script>
</body>
</html>
